(function(b){let c=function(d,e,f){Date.now()>this.lastRedraw+this.redrawInterval?this.redrawInterval?setTimeout(()=>{this.redraw(d,f)}):this.redraw(d,f):this.updateScale()};b.TextSprite=class extends b.Sprite{constructor({textSize:d=1,redrawInterval:e=1,roundFontSizeToNearestPowerOfTwo:f=!0,maxFontSize:g=Infinity,material:h={},texture:i={}}={}){super(new b.SpriteMaterial(Object.assign({},h,{map:new b.TextTexture(i)}))),this._textSize=d,this.redrawInterval=e,this.roundFontSizeToNearestPowerOfTwo=f,this.maxFontSize=g,this.lastRedraw=0,this._renderMesh=new b.Mesh,this._renderMesh.onBeforeRender=c.bind(this),this.add(this._renderMesh)}updateScale(){this.scale.set(this.material.map.aspect,1,1).multiplyScalar(this.textSize)}get textSize(){return this._textSize}set textSize(d){this._textSize!==d&&(this._textSize=d)}computeOptimalFontSize(d,e){if(d.domElement.width&&d.domElement.height&&this.material.map.linesCount){let f=this.getWorldPosition().distanceTo(e.getWorldPosition());if(f){let g=this.getWorldScale().y*d.domElement.height/f;if(g)return Math.round(g/(this.material.map.linesCount+2*this.material.map.padding))}}return 0}redraw(d,e){this.updateScale();let f=this.computeOptimalFontSize(d,e);this.roundFontSizeToNearestPowerOfTwo&&(f=b.Math.nearestPowerOfTwo(f)),f=Math.min(f,this.maxFontSize),this.material.map.fontSize=f,this.lastRedraw=Date.now()}dispose(){this.material.map.dispose(),this.material.dispose()}},Object.assign(b.TextSprite.prototype,{isTextSprite:!0})}).call(this,THREE);